# Autowareコーディング規約

下記に従うようコーディングを行ってください

## ROS開発ガイド

初めに一読しておいてください

- http://wiki.ros.org/DevelopersGuide

## コーディング規約

新規にコードを書くときは ROS標準のコーディング規約に従うようにしてください

### ROS C++コーディング規約

- http://wiki.ros.org/CppStyleGuide

### clang-formatを用いた自動フォーマット

https://github.com/davetcoleman/roscpp_code_format

上記のサイトに ROS C++コーディング規約のための, .clang-formatファイルがある.
このファイルを利用することで, インデントサイズ, カッコ位置等のスタイルに
関する規約については自動で準拠することができる.

#### 利用方法
- clang-formatをインストールする(Ubuntuだとパッケージあり). 新しいバージョンが良い
- プロジェクトのトップディレクトリに .clang-formatファイルを置く
- `clang-format -i filename`とすると .clang-formatに従いフォーマットしてくれる.

`clang-format -i`だとファイルは上書きされるので, 実行前に "git commit"を
しておくと安全である.

システム全体に適用するには以下のようなシェルスクリプトを実行すればよい

```sh
for file in $(git ls-files | \grep -E '\.(c|cpp|h|hpp)$' | \grep -v -- '#')
do
    clang-format -i $file
done
```

### ROS Pythonコーディング規約

- http://wiki.ros.org/PyStyleGuide

PEP8準拠をチェックするツールは [pep8](https://pypi.python.org/pypi/pep8)などで機械的に行えばよい.
現状の ROSは Python2.5をターゲットとしているようだが, Ubuntu 16.04以降では
デフォルトの Pythonのバージョンが 3になるので, 今後の保守を考えると,
Python3準拠で書いておいた方が良いと思う.

## ライブラリ化における注意点
- パッケージ間の依存関係を不必要に増やさない. 循環依存は絶対作らない
- そもそもライブラリ化する必要があるかを検討する
- 他パッケージの msgファイルから生成されたヘッダファイルを includeしない
- テストしやすいように書く

### パッケージ間の依存関係を不必要に増やさない

パッケージ間の依存は少ない方が望ましい. 特に循環参照が発生してしまうと,
ビルドができない状態に陥ってしまう.

### そもそもライブラリ化する必要があるかを検討する

汎用的なもの以外は切り出さない方がいい. パッケージ間の依存を返って高めてしまう可能性がある.
別パッケージにするほど有用かをまず考える. 単に関数の切り出しなら, 同じパッケージ内にライブラリを
作成した方が良い.

### 他パッケージの msgファイルから生成されたヘッダファイルを includeしない

msgファイルから生成されたヘッダファイルを includeすると, ライブラリがその msgを持つ
パッケージに依存してしまう. 結果そのライブラリをリンクするパッケージも, その msgを持つ
パッケージに依存してしまうことになってしまう.

メッセージとして受け取ったデータの処理をライブラリに切り出したい場合は,
メッセージに含まれるデータ型(std::vector<double>等)を渡すようにする.
もしくは別途定義したメッセージの型に依存しない class, structに移し替える.

## 現在のライブラリの実装で気になったところ(2016年 3月 30日現在)

下記のような設計, 実装は推奨されない.

### グローバル変数の多用しすぎている点

ライブラリ側でグローバル変数で状態を保存するのでなく, classや構造体に状態を持たせた
方がよい(errnoのように真に大域的なグローバル変数は例外であるが, そのような変数が
必要になることはほとんどない).

C++であればメソッドとして実装, C言語であれば引数でポインタを渡すように実装すればよい.

またグローバル変数を使う関数の場合は, 複数スレッドを使った場合, 値の取得, 更新に
おいて問題が発生する可能性がある(スレッドセーフ). ROSではユーザの見えないところで
スレッドが使われる可能性もあるため, 極力グローバル変数を使わないことが望ましい.
必要な場合は複数スレッドからのアクセスがあるかを考慮し, その可能性がある場合は
排他制御を行う必要性を検討する.


### ライブラリ関数の引数がない or 戻り値が void型

ライブラリ関数の引数がない or 戻り値が void型ということは副作用のために
関数呼び出しを行うことになる. このような関数はテストしづらく, 理解もしづらい.
ライブラリ関数(not クラスメソッド)については副作用のない関数型スタイルで
あることが望ましい. つまり引数が同一であれば結果が一意になる関数.

### ネーミング

現在のライブラリ関数のネーミングには以下の問題がある
- 名前が単純すぎて理解が難しい
- 名前が単純すぎてシンボル名重複が発生しうる

例えば fusionライブラリには `init`, `destroy`と名前付けされた関数が存在するが,
これだけ見ると何に関する初期化, 終了処理なのかがわからない. また名前が
ありふれているためシンボル名が重複してしまう可能性も高い.

#### 解決案
1. ライブラリの prefixを使う
2. namespaceを使う

##### ライブラリの prefixを使う

上記で挙げた fusionライブラリの場合, `fusion_init`, `fusion_destroy`とする.
こうすることで少なくとも fusionに関する処理ということはわかる.

##### namespaceを使う

全体を `namespace autoware::fusion {}`(もしくは `autoware`)でラップする. 利用するときは
`autoware::fusion::init`, `autoware::fusion_init`等になる. システム全体が namespaceを
使っているのであればこの方法が望ましいと思う(特に Autowareのパッケージを一部だけ
切り出し, 別プロジェクトで使うというケースがある場合).

## export, 非 exportシンボル

exportするシンボルを明確にする. 現在の実装では不必要に多くのシンボルが export
されている. 他パッケージから参照しない関数は exportしないようにする.

C++言語, 無名 namespaceでラップする(ファイルローカルの static指定は非推奨).
class, structであれば privateにする.
C言語では staticを指定し, スコープをファイルローカルにする

## リアルタイム性に関連するコーディング規約・注意点 
 
* 任意の周期でpublishをしない。 
基本的に、トピックが更新されたらpublishするようにしなければならない。つまり、callback内でpublishをする必要がある。 
下記のようなコードは好ましくない。 
```
while(ros::ok()) { 
    publisher.publish(hogehoge); 
    loop.sleep(); 
} 
```

* 2つ以上のトピックを組み合わせるノードは2つのトピックが揃った段階でpublishする。例えば、A,Bトピックをsubscribeしている場合、Aトピックのみ更新されAのcallback関数でpublishしてはいけない。A,Bトピックが更新され2つのペアが完成した段階でpublishする必要がある。下記サンプルコード。 
```
A_callback(A_msg) { 
   if (is_b_callback == true){ // Bトピックがすでに更新されていた場合 
        publish(hogehoge); // データをpublish 
        is_a_callback = false; 
        is_b_callback = false; 
        return; 
    } 
    is_a_callback = true; 
} 
B_callback(B_msg) { 
   if (is_a_callback == true){ 
        publish(hogehoge); 
        is_a_callback = false; 
        is_b_callback = false; 
        return; 
    } 
    is_b_callback = true; 
} 
```
 
* トピック内にheaderを必ず入れ、タイムスタンプは前トピックの値を引き継ぐ。headerのタイムスタンプを引き継がず変更してはならない。尚、2つのトピックを組み合わせる場合は、どちらのトピックのheaderのタイムスタンプを引き継いでも良い。 
※同期により2つのトピックのheaderのタイムスタンプは同一になる 
 
* サービスの利用の禁止。サービスとトピックが混在するとリアルタイム性の見積もりが難しくなる。基本的にはトピックベースで行うべき。自動運転の認知・判断・制御にかかわらない非リアルタイムな部分ではサービスを利用してもよい。 
 
* 大きなデータとトピックとしない。止む終えない場合はnodeletを利用する。大きなデータはシリアライズ・デシリアライズに数msecの時間を要する。そのため、画像などの大きなデータはnodeletを利用し、シリアライズ・デシリアライズを無効にするべき。 
 
* MultiThreadSpinの禁止。MultiThreadSpinを利用した場合、リアルタイムスケジューリングの観点から急激に複雑になるため好ましくない。リアルタイム性を要する処理ではMultiThreadSpinを利用するべきではない。 
 
* launchファイルのoutput=”screen”の禁止。デバッグ中は構わないが、output=”screen”と記述されたものをGitにpushすべきではない。他の人が開発でデバッグしている時、端末の情報が流れてしまう。基本的にはrqtより、ROS_INFOやROS_DEBUGを見るべき。 
 
* tfの利用は極力避ける。current_poseを利用し、位置を取得するべき。tfライブラリはROSと（きっちりわかれていないが）分離されており、リアルタイム性を確保することは難しい。極力トピックベースに統一するため、tfの利用は避けたほうが良い。加えて、tfはアームロボットのように関節が多くある場合は非常に有効だが、自動運転のような静的に座標関係が求まっている場合はあまり有効ではない。 
参考：https://garaemon.github.io/ros/2014/12/31/ros.html 
 
* ノードがあまりにも増えすぎると組込みシステムではローカル通信でも大きな負荷となる。nodeletを利用し、出来る限りポインタ渡しでのトピック通信をするべき。nodelet用のノードは普通のノードと互換性があるため、nodeletを利用しない手はない。しかし、バグがあるとnodeletを利用しているノードが一斉に死亡する可能性がある。 
参考：http://www.slideshare.net/yosukekurihara77/ros-nodelet-20160626-lt 
参考：https://garaemon.github.io/ros/2014/12/31/ros.html 
 
 
 
 
## 一般的な組込み・リアルタイムシステムにおける注意点 
 
* chronoなど多岐にわたるライブラリを利用しない。RTOSへの移植性を大きく低下させる。chronoなどは利用せず、ros::WallTimeなどを利用するべき。 
  * 意見
    * boostライブラリは使用しても問題ないのか。
  * 結論
 
* 関数の引数には出来る限りポインタやconst参照渡しを利用する。intやdoubleはconst参照渡しを利用する必要はないが、vectorや配列にはconst参照渡しを利用するべき。メモリの消費を抑えると同時に、関数呼び出しのオーバーヘッド削減になる。 
 
* 関数の結果は参照引数を利用する。返り値での結果渡しは、速度が著しく遅い。そのため、引数に結果を渡す参照渡し・ポインタを含め返り値はこちらで返すべき。ポインタについては、中身のデータのスコープには十分注意しなければいけない。返り値は基本的に、成功か失敗かなどのエラーに使うと良い。 
http://nonbiri-tereka.hatenablog.com/entry/2014/02/18/091945 
  * 意見
    * プリミティブ型（intやdoubleなど）を結果として返す場合は、値渡しでも問題ないと思われる。あくまで結果をポインタ渡しや参照渡しするのはオブジェクトなどの規模の大きいものだけにしたほうが良いと思われる。
  * 結論
* mallocやnewなどの動的な領域確保は避ける。mallocやnewはメモリリークの発生の原因になる。また、リソースの利用サイズを見積もりにくくするため極力避けるべき。 
 
* vectorの使用するサイズがおおよそ見積もれる場合はreserveを利用する。vectorでは容量が足らなくなった時、2倍の領域を確保する。経験上、サイズの大きいvectorで容共が足らなくなった時、確保に大きな時間を要する。そのため、reserveを利用し、予め領域を確保するべき。 
http://qiita.com/amayaw9/items/6e55b91c28cdc8d32cf2 
 
* 50行以上に及ぶモンスター関数は避ける。どんな関数でも基本的に20～30行以下に抑える。また、関数内の処理の粒度は揃える用に心がける。 
※Effective C++に洗練されたコードのメソッドは平均14行と書いてあったのを覚えています。 
良くない例： 
```
callback() { 
    start_time = clock_get_time(); //粒度・抽象度が地裁 
    compute_hogehoge(); // 粒度・抽象度が非常に大きい 
} 
```
 
* inlineを有効に活用する。1行程度の関数などはインライン展開するべき。ただし、フットプリントの増加を招くので要注意。 
 
* getやsetなどの命名に処理コードを記述しない。getやsetに時間のかかる処理を記述してはいけない。getやsetは値の取得や格納のみを行うべき。名前から処理時間をある程度推定できるようにするべきであり、処理が重たい関数にはcomputeHogeHogeを利用する。 

## 参考文献

C++11(14, 17)には型推論等便利な機能が多く加わっているので, C++11以降の内容が
記載されている本を一読することを推奨する.

- [リーダブルコード](https://www.oreilly.co.jp/books/9784873115658/)
- [プログラミング作法](http://ascii.asciimw.jp/books/books/detail/4-7561-3649-4.shtml)
- [Code Complete上巻](http://ec.nikkeibp.co.jp/item/books/589000.html)
- [Code Complete下巻](http://ec.nikkeibp.co.jp/item/books/589100.html)
- [C++11/14 コア言語](http://asciidwango.jp/post/128762444830/c-1114-コア言語)
- [C++ポケットリファレンス](http://gihyo.jp/book/2015/978-4-7741-7408-2)
- [C++のためのAPIデザイン](http://www.sbcr.jp/products/4797369151.html)
- Effective C++
- C++ Coding Standards
- プログラミング言語C++第4版(C++をもっと知りたくなったあなたに）